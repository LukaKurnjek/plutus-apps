-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Indexers that can rewind the state to a previous version.
--   
--   Please see the README on GitHub at
--   <a>https://github.com/input-output-hk/marconi-core#README.md</a>
@package marconi-core
@version 1.2.0.0

module Marconi.Core.Index.VSplit
data SplitIndex m h v e n q r
SplitIndex :: h -> Storage v m e -> [n] -> (SplitIndex m h v e n q r -> m ()) -> (SplitIndex m h v e n q r -> q -> [e] -> m r) -> (SplitIndex m h v e n q r -> e -> m [n]) -> SplitIndex m h v e n q r
[_handle] :: SplitIndex m h v e n q r -> h
[_storage] :: SplitIndex m h v e n q r -> Storage v m e
[_notifications] :: SplitIndex m h v e n q r -> [n]
[_store] :: SplitIndex m h v e n q r -> SplitIndex m h v e n q r -> m ()
[_query] :: SplitIndex m h v e n q r -> SplitIndex m h v e n q r -> q -> [e] -> m r
[_onInsert] :: SplitIndex m h v e n q r -> SplitIndex m h v e n q r -> e -> m [n]
new :: Monad m => MVector (Mutable v) e => (SplitIndex m h v e n q r -> q -> [e] -> m r) -> (SplitIndex m h v e n q r -> m ()) -> (SplitIndex m h v e n q r -> e -> m [n]) -> Int -> h -> Mutable v (PrimState m) e -> m (Maybe (SplitIndex m h v e n q r))
newBoxed :: Monad m => PrimMonad m => (BoxedIndex m h e n q r -> q -> [e] -> m r) -> (BoxedIndex m h e n q r -> m ()) -> (BoxedIndex m h e n q r -> e -> m [n]) -> Int -> Int -> h -> m (Maybe (BoxedIndex m h e n q r))
newUnboxed :: Monad m => PrimMonad m => MVector MVector e => (UnboxedIndex m h e n q r -> q -> [e] -> m r) -> (UnboxedIndex m h e n q r -> m ()) -> (UnboxedIndex m h e n q r -> e -> m [n]) -> Int -> Int -> h -> m (Maybe (UnboxedIndex m h e n q r))
insert :: forall m h v e n q r. Monad m => PrimMonad m => MVector (Mutable v) e => e -> SplitIndex m h v e n q r -> m (SplitIndex m h v e n q r)
insertL :: PrimMonad m => MVector (Mutable v) e => [e] -> SplitIndex m h v e n q r -> m (SplitIndex m h v e n q r)
size :: SplitIndex m h v e n q r -> Int
rewind :: MVector (Mutable v) e => Int -> SplitIndex m h v e n q r -> Maybe (SplitIndex m h v e n q r)
handle :: forall m_a94H h_a94I v_a94J e_a94K n_a94L q_a94M r_a94N. Lens' (SplitIndex m_a94H h_a94I v_a94J e_a94K n_a94L q_a94M r_a94N) h_a94I
storage :: forall m_a94H h_a94I v_a94J e_a94K n_a94L q_a94M r_a94N. Lens' (SplitIndex m_a94H h_a94I v_a94J e_a94K n_a94L q_a94M r_a94N) (Storage v_a94J m_a94H e_a94K)
notifications :: forall m_a94H h_a94I v_a94J e_a94K n_a94L q_a94M r_a94N. Lens' (SplitIndex m_a94H h_a94I v_a94J e_a94K n_a94L q_a94M r_a94N) [n_a94L]
store :: forall m_a94H h_a94I v_a94J e_a94K n_a94L q_a94M r_a94N. Lens' (SplitIndex m_a94H h_a94I v_a94J e_a94K n_a94L q_a94M r_a94N) (SplitIndex m_a94H h_a94I v_a94J e_a94K n_a94L q_a94M r_a94N -> m_a94H ())
query :: forall m_a94H h_a94I v_a94J e_a94K n_a94L q_a94M r_a94N. Lens' (SplitIndex m_a94H h_a94I v_a94J e_a94K n_a94L q_a94M r_a94N) (SplitIndex m_a94H h_a94I v_a94J e_a94K n_a94L q_a94M r_a94N -> q_a94M -> [e_a94K] -> m_a94H r_a94N)
onInsert :: forall m_a94H h_a94I v_a94J e_a94K n_a94L q_a94M r_a94N. Lens' (SplitIndex m_a94H h_a94I v_a94J e_a94K n_a94L q_a94M r_a94N) (SplitIndex m_a94H h_a94I v_a94J e_a94K n_a94L q_a94M r_a94N -> e_a94K -> m_a94H [n_a94L])
data Storage v m e
Storage :: Mutable v (PrimState m) e -> Int -> Int -> Int -> Int -> Storage v m e
[_events] :: Storage v m e -> Mutable v (PrimState m) e
[_cursor] :: Storage v m e -> Int
[_eSize] :: Storage v m e -> Int
[_bSize] :: Storage v m e -> Int
[_k] :: Storage v m e -> Int
getBuffer :: forall v m e. MVector (Mutable v) e => PrimMonad m => Show e => Storage v m e -> m [e]
getEvents :: forall v m e. MVector (Mutable v) e => PrimMonad m => Show e => Storage v m e -> m [e]
k :: forall v_a7x2 m_a7x3 e_a7x4. Lens' (Storage v_a7x2 m_a7x3 e_a7x4) Int

module Marconi.Core.Index.VSqlite
type SqliteIndex e n q r = SplitIndex IO Connection Vector e n q r
new :: (SqliteIndex e n q r -> q -> [e] -> IO r) -> (SqliteIndex e n q r -> IO ()) -> (SqliteIndex e n q r -> e -> IO [n]) -> Int -> FilePath -> Mutable Vector (PrimState IO) e -> IO (Maybe (SqliteIndex e n q r))
newBoxed :: (BoxedIndex e n q r -> q -> [e] -> IO r) -> (BoxedIndex e n q r -> IO ()) -> (BoxedIndex e n q r -> e -> IO [n]) -> Int -> Int -> FilePath -> IO (Maybe (BoxedIndex e n q r))
insert :: forall m h v e n q r. Monad m => PrimMonad m => MVector (Mutable v) e => e -> SplitIndex m h v e n q r -> m (SplitIndex m h v e n q r)
insertL :: PrimMonad m => MVector (Mutable v) e => [e] -> SplitIndex m h v e n q r -> m (SplitIndex m h v e n q r)
size :: SplitIndex m h v e n q r -> Int
rewind :: MVector (Mutable v) e => Int -> SplitIndex m h v e n q r -> Maybe (SplitIndex m h v e n q r)
getEvents :: forall v m e. MVector (Mutable v) e => PrimMonad m => Show e => Storage v m e -> m [e]
getBuffer :: forall v m e. MVector (Mutable v) e => PrimMonad m => Show e => Storage v m e -> m [e]
handle :: forall m_a94H h_a94I v_a94J e_a94K n_a94L q_a94M r_a94N. Lens' (SplitIndex m_a94H h_a94I v_a94J e_a94K n_a94L q_a94M r_a94N) h_a94I
storage :: forall m_a94H h_a94I v_a94J e_a94K n_a94L q_a94M r_a94N. Lens' (SplitIndex m_a94H h_a94I v_a94J e_a94K n_a94L q_a94M r_a94N) (Storage v_a94J m_a94H e_a94K)

module Marconi.Core.Storable
data Config
memoryBufferSize :: Iso' Config Int
data State h
handle :: forall h_ajTb. Lens' (State h_ajTb) h_ajTb
config :: forall h_ajTb. Lens' (State h_ajTb) Config
emptyState :: PrimMonad (StorableMonad h) => Int -> h -> StorableMonad h (State h)
data Storage h
storage :: forall h_ajTb. Lens' (State h_ajTb) (Storage h_ajTb)
events :: forall h_ajOn h_ajSV. Lens (Storage h_ajOn) (Storage h_ajSV) (MVector (PrimState (StorableMonad h_ajOn)) (SyntheticEvent (StorableEvent h_ajOn) (StorablePoint h_ajOn))) (MVector (PrimState (StorableMonad h_ajSV)) (SyntheticEvent (StorableEvent h_ajSV) (StorablePoint h_ajSV)))
cursor :: forall h_ajOn. Lens' (Storage h_ajOn) Int
getMemoryEvents :: Storage h -> MVector (PrimState (StorableMonad h)) (SyntheticEvent (StorableEvent h) (StorablePoint h))
getEvents :: Buffered h => PrimMonad (StorableMonad h) => State h -> StorableMonad h [StorableEvent h]
filterWithQueryInterval :: forall h. HasPoint (StorableEvent h) (StorablePoint h) => Ord (StorablePoint h) => QueryInterval (StorablePoint h) -> [StorableEvent h] -> [StorableEvent h]
data family StorableEvent h

-- | The resume and query functionality requires a way to specify points on
--   the chain from which we want to resume, or points up to which we want
--   to query.
type family StorablePoint h
data family StorableQuery h
data family StorableResult h
type family StorableMonad h :: * -> *
data QueryInterval p
QEverything :: QueryInterval p
QInterval :: p -> p -> QueryInterval p
data SyntheticEvent e p
Event :: !e -> SyntheticEvent e p
Synthetic :: !p -> SyntheticEvent e p
class Buffered h

-- | This function persists the memory/buffer events to disk when the
--   memory buffer is filled.
persistToStorage :: (Buffered h, Foldable f) => f (StorableEvent h) -> h -> StorableMonad h h
getStoredEvents :: Buffered h => h -> StorableMonad h [StorableEvent h]
class Queryable h
queryStorage :: (Queryable h, Foldable f) => QueryInterval (StorablePoint h) -> f (StorableEvent h) -> h -> StorableQuery h -> StorableMonad h (StorableResult h)
class Resumable h
resumeFromStorage :: Resumable h => h -> StorableMonad h [StorablePoint h]
class Rewindable h
rewindStorage :: Rewindable h => StorablePoint h -> h -> StorableMonad h (Maybe h)
class HasPoint e p
getPoint :: HasPoint e p => e -> p
syntheticPoint :: HasPoint e p => SyntheticEvent e p -> p
foldEvents :: forall f h. Foldable f => f (SyntheticEvent (StorableEvent h) (StorablePoint h)) -> [StorableEvent h]
insert :: Buffered h => PrimMonad (StorableMonad h) => StorableEvent h -> State h -> StorableMonad h (State h)
checkpoint :: Buffered h => PrimMonad (StorableMonad h) => StorablePoint h -> State h -> StorableMonad h (State h)
insertMany :: Foldable f => Buffered h => PrimMonad (StorableMonad h) => f (StorableEvent h) -> State h -> StorableMonad h (State h)
rewind :: forall h. Rewindable h => HasPoint (StorableEvent h) (StorablePoint h) => PrimMonad (StorableMonad h) => Ord (StorablePoint h) => StorablePoint h -> State h -> StorableMonad h (Maybe (State h))
resume :: Resumable h => State h -> StorableMonad h [StorablePoint h]
query :: HasPoint (StorableEvent h) (StorablePoint h) => Ord (StorablePoint h) => Queryable h => PrimMonad (StorableMonad h) => QueryInterval (StorablePoint h) -> State h -> StorableQuery h -> StorableMonad h (StorableResult h)
instance GHC.Generics.Generic (Marconi.Core.Storable.QueryInterval p)
instance GHC.Classes.Eq p => GHC.Classes.Eq (Marconi.Core.Storable.QueryInterval p)
instance GHC.Show.Show p => GHC.Show.Show (Marconi.Core.Storable.QueryInterval p)
instance GHC.Classes.Eq Marconi.Core.Storable.Config
instance GHC.Show.Show Marconi.Core.Storable.Config

module Marconi.Core.TracedStorable
data Config
memoryBufferSize :: Iso' Config Int
data State h
handle :: forall h_andw. Lens' (State h_andw) h_andw
config :: forall h_andw. Lens' (State h_andw) Config
emptyState :: PrimMonad (StorableMonad h) => Int -> h -> StorableMonad h (State h)
data Storage h
storage :: forall h_andw. Lens' (State h_andw) (Storage h_andw)
events :: forall h_anak h_andg. Lens (Storage h_anak) (Storage h_andg) (MVector (PrimState (StorableMonad h_anak)) (SyntheticEvent (StorableEvent h_anak) (StorablePoint h_anak))) (MVector (PrimState (StorableMonad h_andg)) (SyntheticEvent (StorableEvent h_andg) (StorablePoint h_andg)))
cursor :: forall h_anak. Lens' (Storage h_anak) Int
getMemoryEvents :: Storage h -> MVector (PrimState (StorableMonad h)) (SyntheticEvent (StorableEvent h) (StorablePoint h))
getEvents :: Buffered h => PrimMonad (StorableMonad h) => State h -> StorableMonad h [StorableEvent h]
data family StorableEvent h

-- | The resume and query functionality requires a way to specify points on
--   the chain from which we want to resume, or points up to which we want
--   to query.
type family StorablePoint h
data family StorableQuery h
data family StorableResult h
type family StorableMonad h :: * -> *
data family StorableNotifications h
data SyntheticEvent e p
Event :: !e -> SyntheticEvent e p
Synthetic :: !p -> SyntheticEvent e p
data ControlNotification pt n
CNRollForward :: !pt -> ControlNotification pt n
CNRollBack :: !pt -> ControlNotification pt n
CNApplication :: !n -> ControlNotification pt n
class Buffered h

-- | This function persists the memory/buffer events to disk when the
--   memory buffer is filled.
persistToStorage :: (Buffered h, Foldable f) => AppTracer h -> f (StorableEvent h) -> h -> StorableMonad h h
getStoredEvents :: Buffered h => h -> StorableMonad h [StorableEvent h]
class Queryable h
queryStorage :: (Queryable h, Foldable f) => AppTracer h -> StorablePoint h -> f (StorableEvent h) -> h -> StorableQuery h -> StorableMonad h (StorableResult h)
class Resumable h
resumeFromStorage :: Resumable h => AppTracer h -> h -> StorableMonad h [StorablePoint h]
class Rewindable h
rewindStorage :: Rewindable h => AppTracer h -> StorablePoint h -> h -> StorableMonad h (Maybe h)
class HasPoint e p
getPoint :: HasPoint e p => e -> p
syntheticPoint :: HasPoint e p => SyntheticEvent e p -> p
foldEvents :: forall f h. Foldable f => f (SyntheticEvent (StorableEvent h) (StorablePoint h)) -> [StorableEvent h]
insert :: Buffered h => PrimMonad (StorableMonad h) => HasPoint (StorableEvent h) (StorablePoint h) => ControlTracer h -> StorableEvent h -> State h -> StorableMonad h (State h)
checkpoint :: Buffered h => PrimMonad (StorableMonad h) => AppTracer h -> StorablePoint h -> State h -> StorableMonad h (State h)
insertMany :: Foldable f => Buffered h => PrimMonad (StorableMonad h) => HasPoint (StorableEvent h) (StorablePoint h) => ControlTracer h -> f (StorableEvent h) -> State h -> StorableMonad h (State h)
rewind :: forall h. Rewindable h => PrimMonad (StorableMonad h) => Ord (StorablePoint h) => HasPoint (StorableEvent h) (StorablePoint h) => ControlTracer h -> StorablePoint h -> State h -> StorableMonad h (Maybe (State h))
resume :: Resumable h => AppTracer h -> State h -> StorableMonad h [StorablePoint h]
query :: Queryable h => PrimMonad (StorableMonad h) => AppTracer h -> StorablePoint h -> State h -> StorableQuery h -> StorableMonad h (StorableResult h)
instance GHC.Generics.Generic (Marconi.Core.TracedStorable.ControlNotification pt n)
instance GHC.Classes.Eq Marconi.Core.TracedStorable.Config
instance GHC.Show.Show Marconi.Core.TracedStorable.Config
